import { promises as fs } from 'node:fs';
import path from 'node:path';
import crypto from 'node:crypto';
import fg from 'fast-glob';
import type { AiTestsPlanArtifact, IterationRecord, TestGenerationResult, TestRunResult } from '@kb-labs/ai-tests-contracts';
import {
  AUDIT_ARTIFACT_PATH,
  ITERATIONS_ARTIFACT_PATH,
  LOGS_DIR,
  METADATA_ARTIFACT_PATH,
  PLAN_ARTIFACT_PATH,
  RUN_ARTIFACT_PATH,
  SUGGESTIONS_DIR
} from '../../shared/constants.js';
import type { AiTestsWorkspace, PlanDetectionResult } from '../../application/types.js';

async function pathExists(target: string): Promise<boolean> {
  try {
    await fs.access(target);
    return true;
  } catch {
    return false;
  }
}

async function ensureDir(target: string): Promise<void> {
  await fs.mkdir(target, { recursive: true });
}

async function readJsonFile<T>(filePath: string): Promise<T | undefined> {
  try {
    const content = await fs.readFile(filePath, 'utf-8');
    return JSON.parse(content) as T;
  } catch (error) {
    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
      return undefined;
    }
    throw error;
  }
}

async function writeJsonFile(filePath: string, payload: unknown): Promise<void> {
  await ensureDir(path.dirname(filePath));
  await fs.writeFile(filePath, `${JSON.stringify(payload, null, 2)}\n`, 'utf-8');
}

function testFileCandidates(source: string, testsDir: string): { sibling: string[]; dedicated: string[] } {
  const parsed = path.parse(source);
  const sibling = [
    path.join(parsed.dir, `${parsed.name}.test${parsed.ext}`),
    path.join(parsed.dir, `${parsed.name}.spec${parsed.ext}`)
  ];

  const withoutExt = path.join(parsed.dir, parsed.name);
  const relativeToSrc = path.relative('src', withoutExt);
  const normalizedBase = relativeToSrc.startsWith('..') ? withoutExt : relativeToSrc;
  const sanitized = normalizedBase.replace(/\\/g, '/');
  const dedicatedBase = sanitized.replace(/^\.\//, '');

  const dedicated = [
    path.join(testsDir, `${dedicatedBase}.test${parsed.ext}`),
    path.join(testsDir, `${dedicatedBase}.spec${parsed.ext}`)
  ];

  return { sibling, dedicated };
}

function suggestionFilePath(result: TestGenerationResult): string {
  const slugBase = result.request.filePath.replace(/[\\/]/g, '-');
  const hash = crypto.createHash('md5').update(result.outputPath).digest('hex').slice(0, 6);
  return path.join(SUGGESTIONS_DIR, `${slugBase}.${hash}.ts`);
}

export function createWorkspaceAdapter(rootDir = process.cwd()): AiTestsWorkspace {
  const resolve = (...segments: string[]) => path.resolve(rootDir, ...segments);

  return {
    rootDir,

    async ensureTestsDir(testsDir) {
      const target = resolve(testsDir);
      const existed = await pathExists(target);
      await ensureDir(target);
      return { created: !existed };
    },

    async ensureTestsReadme(testsDir, content) {
      const readmePath = path.join(testsDir, 'README.md');
      const target = resolve(readmePath);
      if (await pathExists(target)) {
        return { created: false };
      }
      await ensureDir(path.dirname(target));
      await fs.writeFile(target, content, 'utf-8');
      return { created: true };
    },

    async globSources(globs) {
      return fg(globs, {
        cwd: rootDir,
        absolute: false,
        onlyFiles: true,
        ignore: ['**/*.test.*', '**/*.spec.*', '**/__tests__/**']
      });
    },

    async detectTestsForSources(sources, testsDir) {
      const result: Record<string, PlanDetectionResult> = {};

      for (const source of sources) {
        const { sibling, dedicated } = testFileCandidates(source, testsDir);
        let hasSiblingTest = false;
        for (const candidate of sibling) {
          if (await pathExists(resolve(candidate))) {
            hasSiblingTest = true;
            break;
          }
        }

        let hasDedicatedTest = false;
        for (const candidate of dedicated) {
          if (await pathExists(resolve(candidate))) {
            hasDedicatedTest = true;
            break;
          }
        }

        result[source] = {
          path: source,
          hasSiblingTest,
          hasDedicatedTest
        };
      }

      return result;
    },

    async writeGeneratedTests(results, options = {}) {
      const created: string[] = [];
      const skipped: string[] = [];
      const dryRun: string[] = [];

      for (const result of results) {
        const target = resolve(result.outputPath);
        if (options.dryRun) {
          dryRun.push(result.outputPath);
          continue;
        }

        if (await pathExists(target)) {
          skipped.push(result.outputPath);
          continue;
        }

        await ensureDir(path.dirname(target));
        const header = `// Generated by kb ai-tests on ${new Date().toISOString()}\n`;
        const body = result.blocks.map((block) => block.code).join('\n\n');
        await fs.writeFile(target, `${header}${body}\n`, 'utf-8');
        created.push(result.outputPath);
      }

      return { created, skipped, dryRun };
    },

    async writePlanArtifact(plan) {
      const target = resolve(PLAN_ARTIFACT_PATH);
      await writeJsonFile(target, plan);
      return PLAN_ARTIFACT_PATH;
    },

    async readPlanArtifact() {
      return readJsonFile<AiTestsPlanArtifact>(resolve(PLAN_ARTIFACT_PATH));
    },

    async writeIterations(records) {
      const target = resolve(ITERATIONS_ARTIFACT_PATH);
      await writeJsonFile(target, records);
      return ITERATIONS_ARTIFACT_PATH;
    },

    async readIterations() {
      return (await readJsonFile<IterationRecord[]>(resolve(ITERATIONS_ARTIFACT_PATH))) ?? [];
    },

    async writeRunArtifact(result, log) {
      const runPath = resolve(RUN_ARTIFACT_PATH);
      await writeJsonFile(runPath, result);

      const logsDir = resolve(LOGS_DIR);
      await ensureDir(logsDir);
      const filename = `run-${Date.now()}.log`;
      const logPath = path.join(LOGS_DIR, filename);
      await fs.writeFile(path.join(logsDir, filename), log, 'utf-8');

      return { runPath: RUN_ARTIFACT_PATH, logPath };
    },

    async readRunArtifact() {
      return readJsonFile<TestRunResult>(resolve(RUN_ARTIFACT_PATH));
    },

    async writeMetadata(metadata) {
      await writeJsonFile(resolve(METADATA_ARTIFACT_PATH), metadata);
      return METADATA_ARTIFACT_PATH;
    },

    async writeAudit(markdown) {
      const target = resolve(AUDIT_ARTIFACT_PATH);
      await ensureDir(path.dirname(target));
      await fs.writeFile(target, `${markdown.trim()}\n`, 'utf-8');
      return AUDIT_ARTIFACT_PATH;
    },

    async ensureSuggestions(results) {
      const created: string[] = [];
      for (const result of results) {
        const relativePath = suggestionFilePath(result);
        const target = resolve(relativePath);
        await ensureDir(path.dirname(target));
        await fs.writeFile(target, result.blocks.map((block) => block.code).join('\n\n'), 'utf-8');
        created.push(relativePath);
      }
      return created;
    }
  };
}

